<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>히스토리 계산기 (라이트모드)</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 설정 및 라이트 모드 스타일 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F3F4F6; /* Light Gray Background */
        }
        
        /* 라이트 모드 키 색상 정의 */
        .key { 
            background-color: #FFFFFF; /* White Number/Decimal Key */
            color: #1F2937; /* Dark Text */
            transition: transform 0.1s;
        }
        .key:active { transform: scale(0.95); }

        .operator { 
            background-color: #E5E7EB; /* Gray-200 Operator Key */
            color: #1F2937; 
            transition: transform 0.1s;
        }
        .operator:active { transform: scale(0.95); }

        /* C, (), ±, ⌫ 버튼 스타일 */
        .utility-key {
            background-color: #D1D5DB; /* Gray-300 Utility Key */
            color: #1F2937;
            transition: transform 0.1s;
        }
        .utility-key:active { transform: scale(0.95); }

        .equal { 
            background-color: #10B981; /* Emerald-500 Green Equal Key */
            color: #FFFFFF; /* White Text for contrast */
            transition: transform 0.1s;
        }
        .equal:active { transform: scale(0.95); }

        .clear-key { 
            background-color: #EF4444; /* Red-500 C key */
            color: white; 
            transition: transform 0.1s;
        }
        .clear-key:active { transform: scale(0.95); }

        /* 디스플레이 스타일 */
        #display {
            background-color: #FFFFFF; /* White Display Background */
            color: #1F2937; /* Dark Text */
            border: 1px solid #D1D5DB; /* Subtle border */
        }
        #previous-op {
            color: #6B7280; /* Gray-500 for previous op */
        }
        #current-op {
            color: #1F2937; /* Dark Text for current op */
            /* 입력 모드 시 스타일 */
            caret-color: #10B981; /* 커서 색상 변경 */
        }

        /* 히스토리 사이드바 (라이트 모드 적용) */
        .history-sidebar {
            background-color: #FFFFFF; /* White History Background */
            color: #1F2937; /* Dark Text */
            border: 1px solid #E5E7EB;
        }
        .history-sidebar h2 {
            color: #1F2937;
        }
        .history-sidebar .border-b {
            border-color: #D1D5DB; /* Light gray border for separator */
        }
        .history-item-dark {
            /* History item styling - using dark class but light colors */
            background-color: #F9FAFB; /* Off-white background for history item */
            border-color: #E5E7EB; 
            color: #1F2937;
        }
        .history-item-dark:hover {
            background-color: #EFF6FF; /* Subtle blue hover effect */
        }
        .history-item-dark .text-gray-500 {
             color: #6B7280; /* Darker gray for previous expression */
        }
        .history-item-dark .text-gray-900 {
            color: #1F2937; /* Dark text for result */
        }
        .history-sidebar .text-gray-500 {
            color: #6B7280; /* Text for empty history message */
        }
        
        /* 스크롤바 숨기기 */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* 모바일 우선 반응형 레이아웃 */
        .main-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 40rem; 
            margin: 0 auto;
        }
        @media (min-width: 768px) {
            .main-grid {
                flex-direction: row;
                gap: 1.5rem;
                max-width: 65rem; /* 너비 확장 */
                align-items: flex-start;
            }
            .calculator-card {
                flex: 1; 
                min-width: 384px; 
            }
            .history-sidebar {
                flex: 1; 
                max-height: 90vh; 
            }
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="min-h-screen pt-8 p-4 md:p-8">

    <div class="main-grid">
        <!-- Calculator Card (Left/Top) -->
        <div id="calculator" class="calculator-card w-full max-w-sm bg-white shadow-xl p-5 rounded-3xl transition-all duration-300 mx-auto">
            <!-- Display -->
            <div id="display" class="mb-4 rounded-2xl p-4 flex flex-col items-end justify-end font-light overflow-x-auto whitespace-nowrap scrollbar-hide" style="height: 5rem;">
                <div id="previous-op" class="text-sm h-6"></div>
                <!-- inputmode="decimal"을 추가하여 모바일 환경에서 숫자 키패드를 유도합니다. -->
                <div id="current-op" contenteditable="true" spellcheck="false" 
                     class="text-4xl font-normal h-10 focus:outline-none" 
                     oninput="syncInputAndFormat(this)"
                     inputmode="decimal">0</div>
            </div>

            <!-- Button Grid (Image-based Layout) -->
            <div id="main-button-grid" class="grid grid-cols-4 gap-3">
                
                <!-- Row 1: C, (), ÷, ⌫ (Backspace) -->
                <button class="clear-key text-white text-2xl p-5 aspect-square rounded-full shadow-md" onclick="clearDisplay()">C</button>
                <button class="utility-key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="paren">()</button>
                <button class="operator text-2xl p-5 aspect-square rounded-full shadow-md" data-value="/">÷</button>
                <button class="utility-key text-2xl p-5 aspect-square rounded-full shadow-md" onclick="deleteLast()">⌫</button>
                
                <!-- Row 2: 7, 8, 9, × -->
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="7">7</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="8">8</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="9">9</button>
                <button class="operator text-2xl p-5 aspect-square rounded-full shadow-md" data-value="*">×</button>

                <!-- Row 3: 4, 5, 6, - -->
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="4">4</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="5">5</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="6">6</button>
                <button class="operator text-2xl p-5 aspect-square rounded-full shadow-md" data-value="-">-</button>

                <!-- Row 4: 1, 2, 3, + -->
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="1">1</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="2">2</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="3">3</button>
                <button class="operator text-2xl p-5 aspect-square rounded-full shadow-md" data-value="+">+</button>
                
                <!-- Row 5: +/-, 0, ., = -->
                <button class="utility-key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="plusminus">±</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value="0">0</button>
                <button class="key text-2xl p-5 aspect-square rounded-full shadow-md" data-value=".">.</button>
                <button class="equal text-2xl p-5 aspect-square rounded-full shadow-md" onclick="calculate()">=</button> 
            </div>
        </div>

        <!-- History Sidebar (Right/Bottom) -->
        <div class="history-sidebar w-full md:w-96 bg-white shadow-xl rounded-3xl p-5 overflow-y-auto">
            <div class="mb-4 border-b pb-2">
                <h2 class="text-xl font-bold">계산 기록 (History)</h2>
            </div>
            
            <!-- History List -->
            <div id="history-list" class="space-y-3">
                <!-- History items will be inserted here -->
                <p id="history-empty" class="text-gray-500 text-center text-sm mt-8">기록이 없습니다.</p>
            </div>
        </div>
    </div>

    <script>
        // JavaScript for Calculator Logic
        const currentOpDisplay = document.getElementById('current-op');
        const previousOpDisplay = document.getElementById('previous-op');
        const historyList = document.getElementById('history-list');

        let currentExpression = '';
        let resultDisplayed = false;
        let history = [];
        let openParentheses = 0; // 괄호 카운터

        // 상수 정의
        const LAST_CALCULATION_KEY = 'last_calculation';
        const HISTORY_KEY = 'calculation_history';
        const MAX_HISTORY_ITEMS = 10; // ⭐️ 최대 기록 항목 수 (10개)
        
        // --- 포맷팅 유틸리티 함수 ---

        /**
         * 숫자에 콤마(천 단위 구분 기호)를 추가합니다.
         * @param {string | number} number - 포맷팅할 숫자 또는 숫자 문자열
         * @returns {string} 콤마가 추가된 문자열
         */
        function formatNumberWithCommas(number) {
            if (typeof number !== 'string') {
                number = String(number);
            }
            
            const parts = number.split('.');
            let integerPart = parts[0];
            const decimalPart = parts.length > 1 ? '.' + parts[1] : '';
            const sign = integerPart.startsWith('-') ? '-' : '';
            
            integerPart = integerPart.replace('-', '');
            integerPart = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            
            return sign + integerPart + decimalPart;
        }

        /**
         * 콤마(천 단위 구분 기호)를 제거합니다. (계산용)
         * @param {string} str - 콤마가 포함된 문자열
         * @returns {string} 콤마가 제거된 문자열
         */
        function stripCommas(str) {
            if (typeof str !== 'string') return String(str);
            return str.replace(/,/g, '');
        }

        // --- 커서 관리 유틸리티 ---

        /**
         * 커서 위치를 정수로 저장합니다 (문자열 길이 기반).
         * @param {HTMLElement} element 
         * @returns {number | null}
         */
        function saveCursorPosition(element) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0 || !element.contains(selection.anchorNode)) return null;

            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            // 텍스트 콘텐츠 기준으로 길이 반환
            return preCaretRange.toString().length;
        }

        /**
         * 저장된 커서 위치를 복원합니다.
         * @param {HTMLElement} element 
         * @param {number} position 
         */
        function restoreCursorPosition(element, position) {
            const range = document.createRange();
            const selection = window.getSelection();

            let charCount = 0;
            let found = false;

            function traverse(node) {
                if (found) return;

                if (node.nodeType === Node.TEXT_NODE) {
                    const nodeLength = node.textContent.length;
                    if (charCount + nodeLength >= position) {
                        range.setStart(node, position - charCount);
                        range.collapse(true);
                        found = true;
                    }
                    charCount += nodeLength;
                } else {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        traverse(node.childNodes[i]);
                        if (found) return;
                    }
                }
            }

            traverse(element);

            if (found) {
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                // 커서가 범위 밖인 경우, 끝으로 이동
                range.selectNodeContents(element);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }


        // --- 초기화 및 데이터 로드 ---
        window.onload = function() {
            loadState();
            renderHistory();
            
            // 모든 버튼에 이벤트 리스너를 추가합니다.
            document.querySelectorAll('.key, .operator, .utility-key').forEach(button => {
                button.addEventListener('click', () => {
                    const value = button.getAttribute('data-value');
                    if (value && value.length === 1) { // 숫자, . , 연산자
                        appendToDisplay(value);
                    } else if (value === 'paren') { // 괄호
                        handleParentheses();
                    } else if (value === 'plusminus') { // 부호 변경
                        handlePlusMinus();
                    }
                    
                    // ⭐️ 버튼 클릭 후 소프트 키보드를 숨기기 위해 포커스 제거
                    currentOpDisplay.blur();
                });
            });
        };
        
        /**
         * 로컬 스토리지에서 상태를 로드합니다.
         */
        function loadState() {
            const savedExpression = localStorage.getItem(LAST_CALCULATION_KEY);
            if (savedExpression) {
                currentExpression = savedExpression; // 콤마 없는 원본 수식 로드
                updateDisplay(false); // 포맷팅하여 표시하고 커서를 끝으로 이동
            } else {
                currentOpDisplay.textContent = '0';
            }

            const savedHistory = localStorage.getItem(HISTORY_KEY);
            if (savedHistory) {
                try {
                    history = JSON.parse(savedHistory);
                    if (history.length > MAX_HISTORY_ITEMS) {
                        history.splice(0, history.length - MAX_HISTORY_ITEMS);
                        saveHistory();
                    }
                } catch (e) {
                    console.error("Failed to parse history from localStorage:", e);
                    history = [];
                }
            }
        }

        /**
         * 현재 수식을 로컬 스토리지에 저장합니다.
         */
        function saveExpression() {
            localStorage.setItem(LAST_CALCULATION_KEY, currentExpression);
        }

        /**
         * 히스토리 배열을 로컬 스토리지에 저장합니다.
         */
        function saveHistory() {
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        }
        
        /**
         * 프로그램적으로 현재 수식을 포맷팅하여 화면에 표시합니다.
         * @param {boolean} updateCursor - 커서를 끝으로 이동시킬지 여부
         */
        function updateDisplay(updateCursor = true) {
            // 수식 문자열을 숫자, 연산자, 괄호 등으로 분리하여 포맷팅을 적용합니다.
            const formattedExpression = currentExpression.split(/([+\-*/()])/)
                .map(part => {
                    if (part.length > 0 && (/[0-9]/.test(part) || part === '0.') && !/[+\-*/()]/.test(part)) {
                        return formatNumberWithCommas(part);
                    }
                    return part;
                }).join('');
            
            currentOpDisplay.textContent = formattedExpression || '0';
            currentOpDisplay.scrollLeft = currentOpDisplay.scrollWidth;

            if (updateCursor) {
                // 버튼 클릭 등 프로그램적 업데이트는 커서를 맨 끝으로 보냅니다.
                restoreCursorPosition(currentOpDisplay, currentOpDisplay.textContent.length);
            }

            saveExpression();
        }

        /**
         * 사용자가 직접 입력 필드를 수정할 때 호출되어, 콤마를 포맷하고 문자를 필터링하며 커서를 유지합니다.
         * @param {HTMLElement} element - currentOpDisplay
         */
        function syncInputAndFormat(element) {
            // 1. 현재 커서 위치를 콤마가 포함된 문자열 기준으로 저장
            const savedText = element.textContent || '';
            const savedPos = saveCursorPosition(element);
            
            // 2. 콤마, 공백 제거하여 rawInput을 얻습니다.
            let rawInput = stripCommas(savedText.trim().replace(/\s/g, ''));

            // 3. ⭐️ 입력 필터링: 숫자, 연산자, 괄호, 소수점만 허용
            const sanitizedInput = rawInput.replace(/[^0-9+\-*/().]/g, '');
            const inputWasFiltered = (rawInput !== sanitizedInput);

            // 4. 내부 표현식 업데이트
            currentExpression = sanitizedInput;

            // 5. 포맷팅
            const formattedText = currentExpression.split(/([+\-*/()])/)
                .map(part => {
                    if (part.length > 0 && (/[0-9]/.test(part) || part === '0.') && !/[+\-*/()]/.test(part)) {
                        return formatNumberWithCommas(part);
                    }
                    return part;
                }).join('');
            
            // 6. 디스플레이 텍스트 업데이트
            element.textContent = formattedText || '0';

            // 7. 커서 위치 복원
            if (inputWasFiltered || savedPos === null || savedText === formattedText) {
                // 필터링이 발생했거나 커서 위치를 알 수 없거나 텍스트가 변하지 않은 경우, 끝으로 이동
                restoreCursorPosition(element, formattedText.length);
            } else {
                // 필터링이 없었다면, 커서 위치를 최대한 보존합니다.
                
                // 원본 텍스트(savedText)에서 커서 앞 문자열을 추출하고 콤마를 제거하여 원본 문자 수 계산
                const originalTextBeforeCursor = savedText.substring(0, savedPos);
                const rawCharCountBeforeCursor = stripCommas(originalTextBeforeCursor).length;
                
                // 포맷된 텍스트에서 rawCharCountBeforeCursor와 일치하는 위치 찾기
                let newPos = 0;
                let currentRawCount = 0;
                for (let i = 0; i < formattedText.length; i++) {
                    // 콤마가 아닌 문자가 원본 텍스트와 일치할 경우에만 카운트 증가
                    if (formattedText[i] !== ',') {
                        currentRawCount++;
                    }
                    if (currentRawCount === rawCharCountBeforeCursor) {
                        newPos = i; // 콤마가 제거되지 않은 상태에서의 위치
                        // 바로 다음 문자가 콤마라면 콤마를 건너뛴 위치로 설정
                        if (formattedText[newPos] === ',') {
                            newPos++;
                        }
                        break;
                    }
                    newPos = i + 1; 
                }
                
                restoreCursorPosition(element, newPos);
            }

            saveExpression();
            resultDisplayed = false;
        }

        // --- 히스토리 기능 구현 ---
        
        function renderHistory() {
            historyList.innerHTML = '';
            
            if (history.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-gray-500 text-center text-sm mt-8';
                p.textContent = '기록이 없습니다.';
                historyList.appendChild(p);
                return;
            }

            for (let i = history.length - 1; i >= 0; i--) {
                const item = history[i];

                const div = document.createElement('div');
                div.className = 'history-item history-item-dark p-3 rounded-xl shadow-sm flex justify-between items-start border';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'flex-grow';
                contentDiv.innerHTML = `
                    <div class="text-sm text-gray-500">${item.expression.replace(/\*/g, '×').replace(/\//g, '÷')} =</div>
                    <div class="text-xl text-gray-900 font-semibold">${formatNumberWithCommas(item.result)}</div>
                `;
                contentDiv.addEventListener('click', () => loadFromHistory(item));


                const deleteButton = document.createElement('button');
                deleteButton.className = 'text-gray-400 hover:text-red-400 p-1 ml-2 transition-colors duration-150 rounded-full flex-shrink-0';
                deleteButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                `;
                deleteButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    deleteHistoryItem(i);
                });

                div.appendChild(contentDiv);
                div.appendChild(deleteButton);
                historyList.appendChild(div);
            }
        }

        function loadFromHistory(item) {
            currentExpression = item.expression; 
            previousOpDisplay.textContent = ''; 
            resultDisplayed = false; 
            
            openParentheses = 0;
            currentExpression.split('').forEach(char => {
                if (char === '(') openParentheses++;
                if (char === ')') openParentheses--;
            });

            updateDisplay(); // 포맷팅하여 표시하고 커서를 끝으로 이동
        }

        function deleteHistoryItem(index) {
            history.splice(index, 1); 
            saveHistory();
            renderHistory();
        }


        // --- 계산기 핵심 로직 (버튼 입력 시 커서 끝으로 이동) ---

        function deleteLast() {
            if (currentExpression.length > 0) {
                const lastChar = currentExpression.slice(-1);
                
                if (lastChar === ')') { 
                    openParentheses++; 
                } else if (lastChar === '(') { 
                    openParentheses--; 
                }
                
                currentExpression = currentExpression.slice(0, -1);
                resultDisplayed = false;
                updateDisplay(); 
            } else {
                localStorage.removeItem(LAST_CALCULATION_KEY);
                updateDisplay();
            }
            // ⭐️ 버튼 클릭 후 소프트 키보드를 숨기기 위해 포커스 제거
            currentOpDisplay.blur();
        }

        function handleParentheses() {
            const lastChar = currentExpression.slice(-1);
            const isOperator = /[+\-*/]/.test(lastChar);
            const isNumber = /[0-9]$/.test(lastChar);

            if (resultDisplayed) {
                clearDisplay();
            }

            if (openParentheses > 0 && (isNumber || lastChar === ')')) {
                currentExpression += ')';
                openParentheses--;
            } 
            else if (currentExpression === '' || isOperator || lastChar === '(') {
                currentExpression += '(';
                openParentheses++;
            } 
            else if (isNumber) {
                currentExpression += '(';
                openParentheses++;
            }

            updateDisplay(); 
        }


        function handlePlusMinus() {
            if (resultDisplayed) {
                let result = parseFloat(currentExpression) * -1;
                currentExpression = String(result);
                updateDisplay(); 
                return;
            }

            const match = currentExpression.match(/([+\-*/]?\s*)\(?-?([0-9.]+)$/);
            if (match) {
                const operator = match[1].trim();
                const number = match[2];
                
                let newExpression = currentExpression.slice(0, match.index);
                
                if (operator === '-') {
                    newExpression += `+${number}`;
                } else if (operator === '+') {
                    newExpression += `-${number}`;
                } else if (operator === '' || currentExpression.slice(-1) === '(') { 
                    if (currentExpression.startsWith('-')) {
                        newExpression = currentExpression.slice(1);
                    } else {
                        newExpression = `-${currentExpression}`;
                    }
                } else {
                    newExpression += operator;
                    if (currentExpression.includes('(') || currentExpression.includes(')')) {
                        newExpression += `(-${number})`;
                    } else {
                        newExpression += `(-${number})`;
                    }
                }
                
                currentExpression = newExpression;
                updateDisplay(); 
            } else if (currentExpression.length > 0) {
                if (currentExpression.startsWith('-')) {
                    currentExpression = currentExpression.slice(1);
                } else {
                    currentExpression = `-${currentExpression}`;
                }
                updateDisplay(); 
            }
        }


        function appendToDisplay(value) {
            if (resultDisplayed && /[0-9.]/.test(value)) {
                currentExpression = value;
                resultDisplayed = false;
                previousOpDisplay.textContent = '';
            } else {
                if (resultDisplayed && /[+\-*/]/.test(value)) {
                    resultDisplayed = false;
                    previousOpDisplay.textContent = '';
                } else if (resultDisplayed) {
                    resultDisplayed = false;
                }
                
                const lastChar = currentExpression.slice(-1);
                const isOperator = /[+\-*/]/.test(value);
                const isLastCharOperator = /[+\-*/(]/.test(lastChar);
                
                if (isOperator && /[+\-*/]/.test(lastChar)) {
                    currentExpression = currentExpression.slice(0, -1) + value; 
                } else if (value === '.') {
                    const parts = currentExpression.split(/[+\-*/()]/);
                    const currentNumber = parts[parts.length - 1];
                    if (currentNumber.includes('.')) return;
                    
                    if (currentExpression === '' || isLastCharOperator) {
                        currentExpression += '0.';
                    } else {
                        currentExpression += value;
                    }
                } else {
                    currentExpression += value;
                }
            }

            updateDisplay(); 
        }

        function clearDisplay() {
            currentExpression = '';
            currentOpDisplay.textContent = '0';
            previousOpDisplay.textContent = '';
            resultDisplayed = false;
            openParentheses = 0;
            localStorage.removeItem(LAST_CALCULATION_KEY);
            // C 버튼은 커서를 끝으로 이동 (0이므로 0 뒤)
            restoreCursorPosition(currentOpDisplay, currentOpDisplay.textContent.length);
            // ⭐️ 버튼 클릭 후 소프트 키보드를 숨기기 위해 포커스 제거
            currentOpDisplay.blur();
        }

        function calculate() {
            if (currentExpression === '' || resultDisplayed) return;

            try {
                let expressionToCalculate = currentExpression;
                while(openParentheses > 0) { 
                    expressionToCalculate += ')'; 
                    openParentheses--; 
                }
                
                expressionToCalculate = expressionToCalculate
                    .replace(/÷/g, '/')
                    .replace(/×/g, '*')
                    .replace(/-{2}/g, '+');
                
                if (/[+\-*/]$/.test(expressionToCalculate)) { 
                     expressionToCalculate = expressionToCalculate.slice(0, -1);
                }
                
                if (expressionToCalculate === '') {
                    clearDisplay();
                    return;
                }

                let result = eval(expressionToCalculate);
                let originalExpression = currentExpression;

                if (!isFinite(result)) {
                    currentOpDisplay.textContent = "오류: 0으로 나눔";
                    previousOpDisplay.textContent = originalExpression;
                    currentExpression = '';
                    resultDisplayed = true;
                    return;
                }

                result = parseFloat(result.toFixed(10));
                
                const historyItem = {
                    expression: originalExpression,
                    result: String(result)
                };
                history.push(historyItem);
                
                if (history.length > MAX_HISTORY_ITEMS) {
                    history.shift(); 
                }

                saveHistory();
                renderHistory();

                previousOpDisplay.textContent = `${originalExpression.replace(/\*/g, '×').replace(/\//g, '÷')} =`;
                currentExpression = String(result);
                currentOpDisplay.textContent = formatNumberWithCommas(currentExpression); 
                resultDisplayed = true;
                saveExpression();
                
                // 계산 후 커서를 끝으로 이동
                restoreCursorPosition(currentOpDisplay, currentOpDisplay.textContent.length);
                // ⭐️ 버튼 클릭 후 소프트 키보드를 숨기기 위해 포커스 제거
                currentOpDisplay.blur();

            } catch (error) {
                currentOpDisplay.textContent = "수식 오류";
                previousOpDisplay.textContent = currentExpression.replace(/\*/g, '×').replace(/\//g, '÷');
                currentExpression = '';
                resultDisplayed = true;
                // ⭐️ 버튼 클릭 후 소프트 키보드를 숨기기 위해 포커스 제거
                currentOpDisplay.blur();
            }
        }
    </script>
</body>
</html>


